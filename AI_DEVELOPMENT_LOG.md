# AI Development Log — CollabBoard

## Tools & Workflow

**Primary tool:** Claude Code (CLI agent) — used for the entire project from architecture through implementation, debugging, and documentation. Claude Code handled file creation, editing, running builds, managing git, and orchestrating the full development workflow.

**Secondary tools:** Supabase Dashboard (manual schema verification), Chrome DevTools (real-time sync testing across browser tabs).

**MCP integrations:** Context7 (library documentation lookup), Supabase MCP (database management).

**Workflow pattern:** Describe the feature requirement in natural language → Claude Code explores the codebase, identifies the right files → generates implementation → runs TypeScript compiler to verify → iterates on any errors. For debugging, describe the symptom → Claude traces the code path → identifies root cause → implements fix.

## Effective Prompts

### 1. Architecture bootstrap
> "Build a real-time collaborative whiteboard with Supabase Realtime for sync, React + Konva for rendering, and Zustand for state. Start with cursor sync, then object sync, then persistence."

**Why it worked:** Specifying the build order (cursor → objects → persistence) followed the project's recommended priority order and prevented premature optimization.

### 2. Debugging connector drawing
> "The edge-to-edge connector drawing is not working, the hover detection works but when I click on the dot nothing happens"

**Why it worked:** Precisely describing what works vs. what doesn't let Claude narrow the problem to the interaction between `onDragStart` and React re-renders unmounting the DOM element mid-drag.

### 3. AI agent system prompt
> "Create an AI agent that uses Claude's tool-calling to manipulate the whiteboard. Include tools for all CRUD operations and layout templates for SWOT, kanban, and retrospective boards."

**Why it worked:** Listing specific templates gave Claude concrete examples to encode in the system prompt with exact pixel spacing.

### 4. Performance optimization
> "Add viewport culling to skip rendering objects outside the visible area, and React.memo on all shape components"

**Why it worked:** Specific optimization techniques rather than vague "make it faster" let Claude implement exactly the right pattern.

### 5. Bulk feature request
> "Add the ability to save canvases with specific names, go back to the main page from a canvas, and invite other users to the canvas"

**Why it worked:** Grouping related features in one prompt let Claude design them as a cohesive system (BoardHeader component with back/title/share).

## Code Analysis

| Category | Estimated % |
|----------|------------|
| AI-generated (Claude Code) | ~90% |
| Hand-modified / debugged | ~8% |
| Manual configuration (env files, Supabase dashboard) | ~2% |

The vast majority of code was generated by Claude Code, including all React components, hooks, stores, the AI server, and database migrations. Manual intervention was primarily for environment configuration and Supabase dashboard settings.

## Strengths & Limitations

### Where AI Excelled
- **Boilerplate & patterns:** Generated all 7 shape components with consistent interfaces in seconds
- **Integration code:** Wiring Supabase Realtime channels, presence tracking, and broadcast events
- **Debugging complex interactions:** Traced the connector drag bug through 4 files to find the React re-render race condition
- **System prompt engineering:** Crafted layout templates with precise pixel spacing for SWOT/kanban

### Where AI Struggled
- **Visual layout tuning:** Button sizing, spacing, and responsive layout required back-and-forth with screenshots
- **Supabase RLS policies:** Initial policies caused infinite recursion; needed multiple iterations to fix
- **Edge cases in real-time sync:** 409 conflicts on board_members insert required specific error code handling
- **Canvas coordinate math:** Pointer-relative zoom and world↔screen coordinate conversion needed careful verification

## Key Learnings

1. **Describe symptoms, not solutions** — telling Claude "the dot click does nothing" was more effective than guessing the fix myself. The root cause (DOM unmount during drag) wasn't obvious.

2. **Build vertically, test continuously** — following cursor sync → object sync → persistence order caught integration bugs early rather than discovering them after building the full stack.

3. **AI is excellent at consistency** — once one shape component was right, generating 6 more with identical interfaces was trivial. Humans would likely introduce small inconsistencies.

4. **Screenshots are essential for UI work** — Claude Code can read screenshots, and providing visual feedback on layout issues (button sizing, spacing) was far more effective than describing them in text.

5. **The AI agent building an AI agent** — having Claude Code build the board's AI agent (system prompt, tools, executor) worked remarkably well because it understood both sides of the tool-calling interface.
